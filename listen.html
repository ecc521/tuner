<input id="freq" placeholder="Type Frequency (Hertz)" type="number" onchange="freq()">
<button id="control"></button>

<style>
    #octagon {
      width: 20px;
      height: 20px;
      background: red;
      position: relative;
    }
    #octagon:before {
      content: "";
      width: 20px;
      height: 0;
      position: absolute;
      top: 0;
      left: 0;
      border-bottom: 5.8px solid red;
      border-left: 5.8px solid #eee;
      border-right: 5.8px solid #eee;
    }
    #octagon:after {
      content: "";
      width: 20px;
      height: 0;
      position: absolute;
      bottom: 0;
      left: 0;
      border-top: 5.8px solid red;
      border-left: 5.8px solid #eee;
      border-right: 5.8px solid #eee;
    }  
</style>


<script>

function getid(n){return document.getElementById(n)}

function notefreq(name) {
    //Turn the note name into name and octave
    parent.notefromname(name.slice(0,1), name.slice(1))
}

window.AudioContext = window.AudioContext || window.webkitAudioContext
let ctx = new AudioContext()

window.osc = ctx.createOscillator();
osc.type = "sine"
     

function setactive(boolean) {
  let control = getid("control")
  if (boolean) {
    control.innerHTML = "<div id=/"octagon/"></div>Stop"
    window.active = true
    return ctx.resume()
  } 
  else {
    control.innerHTML = "Play"
    window.active = false
      
    //I would love to be able to use start and stop on the Oscillator Node, but
    //Safari creates AudioContext's in the suspended state, and doesn't let you resume them
    //without explicit user direction
      
    return new Promise(function(resolve,reject){
        if (ctx.state === "suspended") {
            //We don't want to log an error if the context is created suspended - like it is on Safari
            //However Firefox Quantum appears to create context in suspended state, then unsuspend it
            //We will call suspend so the context isn't unsuspended, and just ignore any errors
            ctx.suspend().catch(function(){}) //Firefox
            //I haven't encountered an issue Firefox where this promise resolves before the context is suspended
            //Causing noise to be made. May be because we are just stopping it from being unsuspended. 
            //If it turns out to be an issue, this may have to be changed.
            resolve()
        }
        else {
            ctx.suspend().then(resolve)
        }
    })
      
  }
}


setactive(false).then(function(){
    //We need to wait so that we don't give them a loud suprise
    osc.connect(ctx.destination);
    osc.start()
})

  
    
    
getid("control").addEventListener("click", function() {
    setactive(!window.active)
})
      
  
    

function freq() {
    let value = getid("freq").value
    value = Math.max(20, value)
    value = Math.min(value, 20000)
    getid("freq").value = value
    osc.frequency.value = value
}
    
    

    
    
    

</script>
